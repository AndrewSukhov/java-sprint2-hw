Техническое задание
Как человек обычно делает покупки? Если ему нужен не один продукт,
а несколько, то очень вероятно, что сначала он составит список,
чтобы ничего не забыть. Сделать это можно где угодно: на листе бумаги,
в приложении для заметок или, например, в сообщении самому себе в мессенджере.
А теперь представьте, что это список не продуктов, а полноценных дел.
И не каких-нибудь простых вроде «помыть посуду» или «позвонить бабушке»,
а сложных — например, «организовать большой семейный праздник» или «купить квартиру».
Каждая из таких задач может разбиваться на несколько этапов со своими нюансами и сроками.
А если над их выполнением будет работать не один человек, а целая команда,
то организация процесса станет ещё сложнее.
Трекер задач
Как системы контроля версий помогают команде работать с общим кодом,
так и трекеры задач позволяют эффективно организовать совместную работу
над задачами. Вам предстоит написать бэкенд для такого трекера.
В итоге должна получиться программа, отвечающая за работу этой страницы:
image

Типы задач
Простейшим кирпичиком такой системы является задача (англ. task). У задачи есть следующие свойства:

    Название, кратко описывающее суть задачи (например, «Переезд»).
    Описание, в котором раскрываются детали.
    Уникальный идентификационный номер задачи, по которому её можно будет найти.
    Статус, отображающий её прогресс. Мы будем выделять следующие этапы жизни задачи:
        NEW — задача только создана, но к её выполнению ещё не приступили.
        IN_PROGRESS — над задачей ведётся работа.
        DONE — задача выполнена.

Иногда для выполнения какой-нибудь масштабной задачи её лучше разбить на подзадачи (англ. subtask).
Большую задачу, которая делится на подзадачи, мы будем называть эпиком (англ. epic).
Таким образом, в нашей системе задачи могут быть трёх типов: обычные задачи, эпики и подзадачи.
Для них должны выполняться следующие условия:

    Для каждой подзадачи известно, в рамках какого эпика она выполняется.
    Каждый эпик знает, какие подзадачи в него входят.
    Завершение всех подзадач эпика считается завершением эпика.

Подсказка: как организовать классы для хранения задач
У одной и той же проблемы в программировании может быть несколько решений.
К примеру, вам нужно представить в программе три вида связанных сущностей:
задачи, подзадачи и эпики. Вы можете завести один абстрактный класс и связать
три других с ним. Или создать один не абстрактный класс и двух его наследников.
Или сделать три отдельных класса. Наконец, вы можете представить всё
в одном классе и завести дополнительный enum для представления вида задачи.
Задача программиста — не только сделать выбор, но и обосновать его.
Вне зависимости от того, по какому пути вы решите пойти, каждое из этих
решений будет лучше в одних ситуациях и хуже в других.
На наш взгляд, самым безопасным способом решения этой задачи будет
создание публичного не абстрактного класса model.Task. Он представляет отдельно
стоящую задачу. Далее от него создать два подкласса: model.SubTask и model.Epic.
Такая структура с одной стороны позволит менять свойства сразу всех видов задач,
а с другой — оставит пространство для манёвров, если потребуется изменить только одну из них.


Менеджер
Кроме классов для описания задач, вам нужно реализовать класс для объекта-менеджера.
Он будет запускаться на старте программы и управлять всеми задачами.
В нём должны быть реализованы следующие функции:

    Возможность хранить задачи всех типов. Для этого вам нужно выбрать подходящую коллекцию.
    Методы:
        Получение списка всех задач.
        Получение списка всех эпиков.
        Получение списка всех подзадач определённого эпика.
        Получение задачи любого типа по идентификатору.
        Добавление новой задачи, эпика и подзадачи. Сам объект должен передаваться в качестве параметра.
        Обновление задачи любого типа по идентификатору. Новая версия объекта передаётся в виде параметра.
        Удаление ранее добавленных задач — всех и по идентификатору.
    Управление статусами осуществляется по следующему правилу:
        Менеджер сам не выбирает статус для задачи. Информация о нём приходит
        менеджеру вместе с информацией о самой задаче.
        Для эпиков:
        если у эпика нет подзадач или все они имеют статус NEW, то статус должен быть NEW.
        если все подзадачи имеют статус DONE, то и эпик считается завершённым — со статусом DONE.
        во всех остальных случаях статус должен быть IN_PROGRESS.

Подсказки
Хранение задач
Итак, вам нужно:
1. Получать задачи по идентификатору.
2. Выводить списки задач разных типов.
Один из способов организовать такое хранение — это присвоить соответствие между идентификатором
и задачей при помощи HashMap. Поскольку идентификатор не может повторяться (иначе он не был бы идентификатором),
такой подход позволит быстро получать задачу.
Чтобы получать разные типы задач, вы можете создать три HashMap по одной на каждый из видов задач.

Обновление данных
При обновлении можете считать, что на вход подаётся новый объект, который должен полностью заменить старый.
К примеру, метод для обновления эпика может принимать эпик в качестве входных данных
public void updateEpic(model.Epic epic). Если вы храните эпики в HashMap, где ключами являются идентификаторы,
то обновление — это запись нового эпика epics.put(epic.getId(), epic)).


Обновление статуса задачи
Фраза «информация приходит вместе с информацией по задаче» означает, что не существует отдельного метода,
который занимался бы только обновлением статуса задачи. Вместо этого статус задачи обновляется вместе
с полным обновлением задачи.

Обновление эпиков
Из описания задачи видно, что эпик не управляет своим статусом самостоятельно. Это значит:
1. Пользовать не должен иметь возможности поменять статус эпика самостоятельно.
2. Когда меняется статус любой подзадачи в эпике, вам необходимо проверить,
что статус эпика изменится соответствующим образом. При этом изменение статуса эпика может
и не произойти, если в нём, к примеру, всё ещё есть незакрытые задачи.


И ещё кое-что...

    Проверка кода называется тестированием.
    Мы будем подробно рассказывать об этом дальше в курсе.
    Тем не менее, сам процесс тестирования можно начать уже сейчас.
    Например, вы в любой момент и в любом классе Java можете определить
    метод static void main(String[] args) и внутри него создать
    экземпляры нужных вам классов и вызвать их методы. Второй способ —
    добавить в код вывод информации через System.out.println(..).
    Главное — не забудьте потом убрать это вызовы. Наконец, вы можете
    воспользоваться дебаггером, поставляемым вместе со средой разработки.
    Не оставляйте в коде мусор — превращённые в комментарии или ненужные
    куски кода. Это сквозной проект, на его основе вы будете делать следующие
    домашние задания.
    Давайте коммитам осмысленные комментарии: порядок в репозитории и коде —
    ключ к успеху написания хороших программ.

Интересного вам программирования!

Спринт 5.

Техническое задание
В этом спринте вы добавите в трекер задач ещё одну полезную опцию.
Текущая реализация хранит состояние менеджера в оперативной памяти,
из-за этого после перезапуска приложения все нужные нам данные теряются.
Решить эту проблему может такой класс менеджера, который будет после каждой
операции автоматически сохранять все задачи и их состояние в специальный файл.
Вам предстоит создать вторую реализацию менеджера. У него будет такая же система
классов и интерфейсов, как и у нынешнего. Новый и старый менеджеры будут отличаться
только деталями реализации методов: один хранит информацию в оперативной памяти, другой — в файле.
Вторая реализация менеджера
Итак, создайте класс FileBackedTasksManager. В нём вы будете прописывать логику
автосохранения в файл. Этот класс, как и InMemoryTasksManager,
должен имплементировать интерфейс менеджера TasksManager.

Теперь нужно написать реализацию для нового класса. Если у вас появится
желание просто скопировать код из InMemoryTasksManager и дополнить его
в нужных местах функцией сохранения в файл, остановитесь! Старайтесь
избегать дублирования кода, это признак плохого стиля.
В данном случае есть более изящное решение: можно наследовать
FileBackedTasksManager от InMemoryTasksManager и получить от класса-родителя
желаемую логику работы менеджера. Останется только дописать в некоторых
местах вызовы метода автосохранения.

Метод автосохранения
Пусть новый менеджер получает файл для автосохранения в своём конструкторе
и сохраняет его в поле. Создайте метод save без параметров — он будет
сохранять текущее состояние менеджера в указанный файл.
Теперь достаточно переопределить каждую модифицирующую операцию таким
образом, чтобы сначала выполнялась версия,
унаследованная от предка, а затем — метод save. Например:

@Override
public void addSubtask(Subtask subtask) {
    super.addSubtask(subtask);
    save();
}


Затем нужно продумать логику метода save. Что он должен сохранять?
Все задачи, подзадачи, эпики и историю просмотра любых задач.
Для удобства работы рекомендуем выбрать текстовый формат CSV
(англ. Comma-Separated Values, «значения, разделённые запятыми»).
Тогда файл с сохранёнными данными будет выглядеть так:

id,type,name,status,description,epic
1,TASK,Task1,NEW,Description task1,
2,EPIC,Epic2,DONE,Description epic2,
3,SUBTASK,Sub Task2,DONE,Description sub task3,2

2,3

Сначала через запятую перечисляются все поля задач. Ниже находится список задач,
каждая из них записана с новой строки. Дальше — пустая строка, которая отделяет
задачи от истории просмотров. И заключительная
строка — это идентификаторы задач из истории просмотров.
Файл из нашего примера можно прочитать так: в трекер добавлены задача,
эпик и подзадача. Эпик и подзадача просмотрены и выполнены.
Задача осталась в состоянии новой и не была просмотрена.

Как сохранять задачи в файл и считывать их из него

    Создайте enum с типами задач.
    Напишите метод сохранения задачи в строку
    String toString(Task task) или переопределите базовый.
    Напишите метод создания задачи из строки Task fromString(String value).
    Напишите статические методы static String toString(HistoryManager manager)
    и static List<Integer> fromString(String value) для сохранения
    и восстановления менеджера истории из CSV.

Как прочитать файл
В Java есть несколько способов чтения файлов. Вы можете использовать такой:

Files.readString(Path.of(path));

Проверка работы нового менеджера
Исключения вида IOException нужно отлавливать внутри метода save и кидать собственное
непроверяемое исключение ManagerSaveException. Благодаря этому можно
не менять сигнатуру методов интерфейса менеджера.
💡 Мы исходим из того, что наш менеджер работает в идеальных условиях.
Над ним не совершаются недопустимые операции, и все его действия
со средой (например, сохранение файла) завершаются успешно.
Помимо метода сохранения создайте статический метод
static FileBackedTasksManager loadFromFile(File file),
который будет восстанавливать данные менеджера из файла при запуске программы.
Не забудьте убедиться, что новый менеджер задач работает так же, как предыдущий.
И проверьте работу сохранения и восстановления менеджера из файла (сериализацию).
Для этого создайте метод static void main(String[] args) в классе
FileBackedTasksManager и реализуйте небольшой сценарий:

    Заведите несколько разных задач, эпиков и подзадач.
    Запросите некоторые из них, чтобы заполнилась история просмотра.
    Создайте новый FileBackedTasksManager менеджер из этого же файла.
    Проверьте, что история просмотра восстановилась верно и все задачи,
    эпики, подзадачи, которые были в старом, есть в новом менеджере.

Итог
У вас должно появиться несколько новых классов, а также новый менеджер
с опцией сохранения состояния. Убедитесь, что он работает корректно,
и отправляйте свой код на ревью.

ЗАДАНИЕ 6.
Пора потренироваться! Теперь вы знаете, что без тестов нельзя проверить программу и убедиться, что всё работает именно так, как задумано. В трекере уже есть код проверки — он содержится в методах main. На основе этого кода вам предстоит написать тесты для менеджеров и задач.
Также в этом спринте вы добавите новую функциональность: приложение сможет расставлять задачи по приоритету и проверять, не пересекаются ли они по времени выполнения. Вперёд!
Добавьте JUnit в проект
Прежде чем приступать к написанию тестов, добавьте поддержку JUnit в проект. Для этого выполните в IntelliJ IDEA следующие действия.

    Откройте любой класс, например Epic.
    Нажмите Ctrl+Shift+T. В выпадающем меню выберите пункт Create test (англ. «Создать тест»). В появившемся окне нажмите кнопку OK — тест будет размещён в той же папке. image
    В меню выбора теста (Testing library) выберите JUnit5, а затем нажмите кнопку Fix (англ. «Исправить»).
    image
    Скачайте библиотеку в папку lib. Поставьте галочку около пункта Download to (англ. «Скачать в...») и нажмите кнопку OK, чтобы подтвердить создание теста.
    image
    После этого откроется файл EpicTest. Можно переходить к написанию тестов.

💡 Проверьте, что все библиотеки загрузились в папку lib.
image
Покройте код тестами
Ваша цель — написать отдельный тест для каждого публичного метода: стандартный кейс его работы и граничные случаи.
Потребуются следующие тесты.

    Для расчёта статуса Epic. Граничные условия:
    a. Пустой список подзадач.
    b. Все подзадачи со статусом NEW.
    c. Все подзадачи со статусом DONE.
    d. Подзадачи со статусами NEW и DONE.
    e. Подзадачи со статусом IN_PROGRESS.
    Для двух менеджеров задач InMemoryTasksManager и FileBackedTasksManager.
        Чтобы избежать дублирования кода, необходим базовый класс с тестами на каждый метод из интерфейса abstract class TaskManagerTest<T extends TaskManager>.
        Для подзадач нужно дополнительно проверить наличие эпика, а для эпика — расчёт статуса.
        Для каждого метода нужно проверить его работу:
        a. Со стандартным поведением.
        b. С пустым списком задач.
        c. С неверным идентификатором задачи (пустой и/или несуществующий идентификатор).
    Для HistoryManager — тесты для всех методов интерфейса. Граничные условия:
    a. Пустая история задач.
    b. Дублирование.
    с. Удаление из истории: начало, середина, конец.
    Дополнительно для FileBackedTasksManager — проверка работы по сохранению и восстановлению состояния. Граничные условия:
    a. Пустой список задач.
    b. Эпик без подзадач.
    c. Пустой список истории.

После написания тестов ещё раз проверьте их наличие по списку. Убедитесь, что они работают.
Подсказка: примеры тестов
Добавьте продолжительность и дату старта
Добавьте новые поля в задачи:

    duration — продолжительность задачи, оценка того, сколько времени она займёт в минутах (число);
    startTime — дата, когда предполагается приступить к выполнению задачи.
    getEndTime() — время завершения задачи, которое рассчитывается исходя из startTime и duration.

Менять сигнатуры методов интерфейса TaskManager не понадобится: при создании или обновлении задач все его методы будут принимать и возвращать объект, в который вы добавите два новых поля.
С классом Epic придётся поработать дополнительно. Продолжительность эпика — сумма продолжительности всех его подзадач. Время начала — дата старта самой ранней подзадачи, а время завершения — время окончания самой поздней из задач. Новые поля duration и startTime этого класса будут расчётные — аналогично полю статус. Для реализации getEndTime() удобно добавить поле endTime в Epic и рассчитать его вместе с другими полями.
Не забудьте также доработать опцию сохранения состояния в файл: добавьте в сериализацию новые поля.
Добавьте в тесты проверку новых полей.
Выведите список задач в порядке приоритета
Отсортируйте все задачи по приоритету — то есть по startTime. Если дата старта не задана, добавьте задачу в конец списка задач, подзадач, отсортированных по startTime. Напишите новый метод getPrioritizedTasks, возвращающий список задач и подзадач в заданном порядке.
Предполагается, что пользователь будет часто запрашивать этот список задач и подзадач, поэтому подберите подходящую структуру данных для хранения. Сложность получения должна быть уменьшена с O(n log n) до O(n).
Подсказка: как ускорить сортировку
Проверьте пересечения
Предполагается, что пользователь будет выполнять не более одной задачи за раз. Научите трекер проверять, что задачи и подзадачи не пересекаются по времени выполнения. Добавьте валидацию во время создания или изменения задач, подзадач.
Подсказка: как искать пересечения за O(n)
Дополнительное задание*
А теперь необязательное задание для тех, кто хочет бросить себе вызов! Подумайте, какая структура данных и какой алгоритм проверки подойдут, чтобы уменьшить сложность поиска пересечений до O(1).
Подсказка: как искать пересечения за O(1)
Не забудьте перепроверить код перед отправкой на ревью!
Интересного вам программирования!

